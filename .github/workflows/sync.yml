name: 设备数据与工作流同步

on:
  # 手动触发同步
  workflow_dispatch:
  # 每日自动同步（凌晨3点执行）
  schedule:
    - cron: '0 3 * * *'

# 全局环境变量（确保全流程UTF-8编码与统一时区）
env:
  LC_ALL: en_US.UTF-8
  LANG: en_US.UTF-8
  LANGUAGE: en_US.UTF-8
  TZ: Asia/Shanghai  # 统一时区为上海，避免日志时间混乱

jobs:
  sync-and-generate:
    name: 同步设备信息并生成工作流
    runs-on: ubuntu-22.04
    timeout-minutes: 240  # 充足的超时时间应对耗时操作

    steps:
      - name: 拉取代码仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          lfs: true
          path: ./openwrt-builder  # 简化工作目录路径

      - name: 进入工作目录
        run: |
          cd openwrt-builder
          pwd  # 输出当前目录，便于调试路径问题

      - name: 安装系统依赖（自动适配最新版本，增强容错）
        run: |
          cd openwrt-builder
          # 更新包索引（带容错参数）
          sudo apt update -y --fix-missing
          
          # 安装基础工具（无版本依赖的核心包）
          sudo apt install -y \
            build-essential git jq grep sed gawk \
            file gcc g++ dos2unix curl wget zip unzip \
            snapd locales  # 移除apt的golang，改用动态安装最新版
          
          # 配置UTF-8本地化（彻底解决中文编码问题）
          sudo locale-gen en_US.UTF-8
          sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
          echo "当前系统编码: $(locale)"  # 验证编码配置
          
          # ==============================================
          # 动态获取并安装最新版Go（增加容错机制）
          # ==============================================
          echo "获取最新Go稳定版..."
          # 定义重试次数和默认版本（已知稳定版）
          MAX_RETRIES=3
          DEFAULT_GO_VERSION="1.22.5"
          GO_LATEST_TAG="null"
          
          # 重试机制：最多请求3次GitHub API（带超时和连接重试）
          for ((i=1; i<=MAX_RETRIES; i++)); do
            echo "尝试第$i次请求GitHub API..."
            GO_LATEST_TAG=$(curl -s --retry 3 --connect-timeout 10 "https://api.github.com/repos/golang/go/releases/latest" | jq -r '.tag_name')
            if [ "$GO_LATEST_TAG" != "null" ] && [ -n "$GO_LATEST_TAG" ]; then
              echo "API请求成功，获取到最新版本标签: $GO_LATEST_TAG"
              break
            fi
            echo "第$i次请求失败，等待2秒后重试..."
            sleep 2
          done
          
          # 如果多次重试后仍失败，使用默认版本
          if [ "$GO_LATEST_TAG" = "null" ] || [ -z "$GO_LATEST_TAG" ]; then
            echo "⚠️ 无法获取最新Go版本，使用默认稳定版: $DEFAULT_GO_VERSION"
            GO_LATEST_TAG="go$DEFAULT_GO_VERSION"
          fi
          
          # 提取纯版本号（如从go1.22.5提取1.22.5）
          GO_LATEST_VERSION=$(echo "$GO_LATEST_TAG" | sed 's/^go//')
          echo "最终使用的Go版本: $GO_LATEST_VERSION"
          
          # 下载并安装Go（双重链接保障）
          GO_TAR="go${GO_LATEST_VERSION}.linux-amd64.tar.gz"
          if ! wget "https://dl.google.com/go/${GO_TAR}" -O /tmp/${GO_TAR}; then
            echo "❌ 谷歌官方源下载失败，切换到备用源..."
            if ! wget "https://gomirrors.org/dl/go/${GO_TAR}" -O /tmp/${GO_TAR}; then
              echo "❌ 所有源下载失败，终止流程"
              exit 1
            fi
          fi
          
          # 安装Go到系统目录（清理旧版本）
          sudo rm -rf /usr/local/go
          sudo tar -C /usr/local -xzf /tmp/${GO_TAR}
          export PATH="/usr/local/go/bin:$PATH"  # 临时添加到环境变量
          go version  # 验证安装结果
          
          # ==============================================
          # 安装最新版yamlfmt（自动跟随上游更新）
          # ==============================================
          echo "安装最新版yamlfmt..."
          go install github.com/google/yamlfmt/cmd/yamlfmt@latest  # @latest自动拉取最新版
          echo "$HOME/go/bin" >> $GITHUB_PATH  # 永久添加到环境变量
          
          # ==============================================
          # 安装最新版yq（通过snap自动维护更新）
          # ==============================================
          echo "安装最新版yq..."
          sudo snap install yq  # snap会自动更新到最新稳定版
          
          # ==============================================
          # 验证所有工具版本（确保兼容性）
          # ==============================================
          echo "===== 工具版本验证 ====="
          jq --version
          yq --version
          yamlfmt --version
          git --version
          gawk --version
          go version
          echo "======================="

      - name: 准备脚本文件（确保证编码和权限）
        run: |
          cd openwrt-builder
          # 创建必要目录（若不存在）
          mkdir -p scripts sync-logs configs
          
          # 赋予脚本执行权限（递归处理所有.sh文件）
          find scripts -name "*.sh" -exec chmod +x {} \;
          
          # 转换换行符（防止Windows格式导致脚本执行错误）
          find scripts -name "*.sh" -exec dos2unix {} \;
          
          # 验证文件编码（确保为UTF-8）
          echo "===== 脚本编码验证 ====="
          find scripts -name "*.sh" -exec file -i {} \;
          echo "======================="

      - name: 执行设备数据同步（含驱动提取，带超时控制）
        run: |
          cd openwrt-builder
          # 执行同步脚本并记录详细日志（含时间戳），超时控制为120分钟
          timeout 7200 ./scripts/sync-devices.sh | tee sync-logs/sync-$(date +%Y%m%d_%H%M%S).log
          exit_code=$?
          if [ $exit_code -eq 124 ]; then
            echo "❌ 设备同步脚本执行超时（超过120分钟）"
            exit 1
          elif [ $exit_code -ne 0 ]; then
            echo "❌ 设备同步脚本执行失败（退出码：$exit_code）"
            exit $exit_code
          fi

      - name: 生成编译工作流文件（带日志）
        run: |
          cd openwrt-builder
          # 生成工作流并记录日志，超时控制为60分钟
          timeout 3600 ./scripts/generate-workflow.sh | tee sync-logs/workflow-$(date +%Y%m%d_%H%M%S).log
          exit_code=$?
          if [ $exit_code -eq 124 ]; then
            echo "❌ 工作流生成脚本执行超时（超过60分钟）"
            exit 1
          elif [ $exit_code -ne 0 ]; then
            echo "❌ 工作流生成脚本执行失败（退出码：$exit_code）"
            exit $exit_code
          fi

      - name: 严格验证同步结果（防乱码和完整性）
        run: |
          cd openwrt-builder
          echo "===== 结果验证 ====="
          
          # 验证核心文件存在性
          critical_files=(
            ".github/workflows/build.yml"
            "device-drivers.json"
            "sync-logs/source_branches.tmp"
          )
          for file in "${critical_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "❌ 核心文件不存在：$file"
              exit 1
            fi
            if [ ! -s "$file" ]; then
              echo "❌ 核心文件为空：$file"
              exit 1
            fi
          done
          
          # 验证中文内容存在（非强制，作为警告）
          if ! grep -qE '[一-龥]' "device-drivers.json"; then
            echo "⚠️ 警告：设备JSON中未检测到中文字符，可能存在编码问题"
          fi
          
          # 验证JSON和YAML格式合法性
          if ! jq . "device-drivers.json" > /dev/null; then
            echo "❌ 设备JSON格式错误"
            exit 1
          fi
          
          if ! yq eval '.' ".github/workflows/build.yml" > /dev/null; then
            echo "❌ 工作流YAML格式错误"
            exit 1
          fi
          
          echo "✅ 验证通过"

      - name: 提交同步结果（确保中文正常提交）
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          repository: ./openwrt-builder
          commit_message: "自动同步设备数据与工作流（${{ github.sha }}）"
          file_pattern: |
            .github/workflows/build.yml
            device-drivers.json
            sync-logs/*.log
            sync-logs/source_branches.tmp
            configs/*.json
          commit_user_name: "同步机器人"
          commit_user_email: "sync-bot@example.com"
          encoding: "utf-8"  # 强制UTF-8编码提交，避免中文乱码
          push_options: --force-with-lease  # 安全推送，避免覆盖他人提交

      - name: 上传同步日志（便于调试）
        uses: actions/upload-artifact@v4
        with:
          name: sync-logs-${{ github.run_id }}
          path: openwrt-builder/sync-logs/*.log
          retention-days: 7  # 日志保留7天，节省存储空间
          if-no-files-found: warn  # 无日志时仅警告，不中断流程
