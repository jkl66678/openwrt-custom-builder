name: OpenWrt全自动化编译系统

on:
  workflow_dispatch:
    inputs:
      select_mode:
        type: choice
        description: 编译模式（设备/芯片）
        required: true
        options: [device, chip]

      device:
        type: choice
        description: 设备型号（仅设备模式）
        required: false
        options: [cudy-tr3000, redmi-ac2100, x86-64-generic, phicomm-k2p]  # 会被自动更新

      chip:
        type: choice
        description: 芯片型号（仅芯片模式）
        required: false
        options: [mt7981, mt7621, x86_64, ipq8065, bcm53573]  # 会被自动更新

      source_branch:
        type: choice
        description: 源码分支
        required: true
        options: [openwrt-23.05, openwrt-master, immortalwrt-23.05, immortalwrt-master]

      theme_and_optimization:
        type: choice
        description: 主题+优化组合
        required: true
        options:
          - argon-O2-generic
          - argon-O3-armv8
          - argon-O3-x86
          - bootstrap-O2-generic
          - material-Os-generic

      core_features:
        type: choice
        description: 核心功能
        required: true
        options: [ipv6+accel, ipv6-only, accel-only, none]

      packages:
        type: string
        description: 软件包（逗号分隔）
        required: false
        default: "openclash,samba,ddns-scripts,luci-app-upnp"

      rootfs_size:
        type: number
        description: 根分区大小(MB)
        required: true
        default: 192

      firmware_suffix:
        type: string
        description: 固件后缀
        required: false
        default: "custom"

      run_custom_script:
        type: boolean
        description: 执行自定义脚本
        required: true
        default: true

  schedule:
    - cron: "0 0 * * 0"  # 每周日同步设备


jobs:
  sync-and-generate:
    name: 同步设备并生成工作流
    runs-on: ubuntu-latest
    steps:
      - name: 拉取仓库代码
        uses: actions/checkout@v4

      - name: 安装依赖
        run: |
          sudo apt update
          sudo apt install -y git jq gh

      - name: 检查同步脚本
        run: |
          if [ ! -f "scripts/sync-devices.sh" ]; then
            echo "❌ 未找到 scripts/sync-devices.sh"
            exit 1
          fi
          chmod +x scripts/sync-devices.sh

      - name: 执行设备同步
        run: ./scripts/sync-devices.sh

      - name: 生成动态工作流（更新设备选项）
        run: |
          # 提取设备和芯片列表
          DEVICES=$(jq -r '.devices[].name' device-drivers.json | sort | uniq | tr '\n' ' ')
          CHIPS=$(jq -r '.chips[].name' device-drivers.json | sort | uniq | tr '\n' ' ')
          
          # 替换工作流中的选项
          sed -i "s/options: \[.*\]  # 会被自动更新/options: [$DEVICES]  # 会被自动更新/" .github/workflows/build.yml
          sed -i "s/options: \[.*\]  # 会被自动更新/options: [$CHIPS]  # 会被自动更新/" .github/workflows/build.yml

      - name: 提交更新
        run: |
          git config --global user.name "Auto-Sync Bot"
          git config --global user.email "bot@github.com"
          git add device-drivers.json .github/workflows/build.yml
          if git diff --cached --quiet; then
            echo "⚠️ 无设备更新"
          else
            git commit -m "自动更新设备列表（$(date +%Y%m%d)）"
            git push
          fi


  build-firmware:
    name: 编译固件
    needs: sync-and-generate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
      packages: write

    steps:
      - name: 拉取最新代码
        uses: actions/checkout@v4

      - name: 安装编译依赖
        run: |
          sudo apt update
          sudo apt install -y build-essential libncurses5-dev libncursesw5-dev \
            zlib1g-dev gawk git gettext libssl-dev xsltproc wget unzip python3 jq \
            time curl ca-certificates

      - name: 硬件资源检测
        run: |
          CPU_CORES=$(grep -c ^processor /proc/cpuinfo)
          AVAIL_MEM=$(free -m | awk '/^Mem:/ {print $7}')
          echo "CPU_CORES=$CPU_CORES" >> $GITHUB_ENV
          echo "AVAIL_MEM=$AVAIL_MEM" >> $GITHUB_ENV

      - name: 动态计算线程数
        run: |
          OPT_LEVEL=$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f2)
          ARCH=$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f3)
          
          MIN_MEM_PER_THREAD=$([ "$OPT_LEVEL" = "O3" ] && echo 2048 || echo 1024)
          [ "$ARCH" = "armv8" ] && MIN_MEM_PER_THREAD=$((MIN_MEM_PER_THREAD * 12 / 10))
          
          MAX_THREADS_BY_MEM=$((AVAIL_MEM / MIN_MEM_PER_THREAD))
          MAX_THREADS_BY_CPU=${{ env.CPU_CORES }}
          FINAL_THREADS=$((MAX_THREADS_BY_MEM < MAX_THREADS_BY_CPU ? MAX_THREADS_BY_MEM : MAX_THREADS_BY_CPU))
          FINAL_THREADS=$((FINAL_THREADS < 1 ? 1 : FINAL_THREADS))
          
          [ "$OPT_LEVEL" = "O3" ] && [ "$ARCH" = "armv8" ] && [ $FINAL_THREADS -gt 2 ] && FINAL_THREADS=2
          echo "THREADS=$FINAL_THREADS" >> $GITHUB_ENV

      - name: 解析编译参数
        run: |
          # 解析主题和优化
          theme_opt="${{ github.event.inputs.theme_and_optimization }}"
          echo "THEME=$(echo "$theme_opt" | cut -d'-' -f1)" >> $GITHUB_ENV
          echo "CFLAGS=-$(echo "$theme_opt" | cut -d'-' -f2)" >> $GITHUB_ENV
          
          # 解析核心功能
          case "${{ github.event.inputs.core_features }}" in
            "ipv6+accel") echo "ENABLE_IPV6=true"; echo "ENABLE_ACCEL=true" ;;
            "ipv6-only") echo "ENABLE_IPV6=true"; echo "ENABLE_ACCEL=false" ;;
            "accel-only") echo "ENABLE_IPV6=false"; echo "ENABLE_ACCEL=true" ;;
            "none") echo "ENABLE_IPV6=false"; echo "ENABLE_ACCEL=false" ;;
          esac | tee -a $GITHUB_ENV
          
          # 解析软件包
          packages="${{ github.event.inputs.packages }}"
          echo "PACKAGES=$(echo "$packages" | tr ',' '\n' | grep -v 'luci-app-' | sed 's/^/luci-app-/g' | tr '\n' ' ')$(echo "$packages" | tr ',' '\n' | grep 'luci-app-' | tr '\n' ' ')" >> $GITHUB_ENV

      - name: 拉取源码（带重试）
        run: |
          fetch_source() {
            local repo=$1 branch=$2 retries=3
            while [ $retries -gt 0 ]; do
              if git clone --depth 1 --branch "$branch" "$repo" openwrt-src; then
                [ -n "$(ls -A openwrt-src)" ] && return 0
              fi
              retries=$((retries - 1))
              rm -rf openwrt-src
              sleep 5
            done
            exit 1
          }
          
          case "${{ github.event.inputs.source_branch }}" in
            openwrt-23.05) fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "openwrt-23.05" ;;
            openwrt-master) fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "master" ;;
            immortalwrt-23.05) fetch_source "https://github.com/immortalwrt/immortalwrt.git" "openwrt-23.05" ;;
            immortalwrt-master) fetch_source "https://github.com/immortalwrt/immortalwrt.git" "master" ;;
          esac
          echo "SRC_DIR=$(pwd)/openwrt-src" >> $GITHUB_ENV

      - name: 初始化源码与主题
        run: |
          cd "${{ env.SRC_DIR }}"
          ./scripts/feeds update -a && ./scripts/feeds install -a
          
          # 添加主题源
          [ "${{ env.THEME }}" = "argon" ] && echo 'src-git argon https://github.com/jerrykuku/luci-theme-argon.git' >> feeds.conf.default
          [ "${{ env.THEME }}" = "material" ] && echo 'src-git material https://github.com/LuttyYang/luci-theme-material.git' >> feeds.conf.default
          
          # 添加OpenClash源（非ImmortalWrt）
          if [[ "${{ env.PACKAGES }}" == *"luci-app-openclash"* && ! "${{ github.event.inputs.source_branch }}" == *"immortalwrt"* ]]; then
            echo 'src-git openclash https://github.com/vernesong/OpenClash.git' >> feeds.conf.default
          fi
          
          ./scripts/feeds update -a && ./scripts/feeds install -a

      - name: 执行自定义脚本
        if: ${{ github.event.inputs.run_custom_script == 'true' }}
        run: |
          cd "${{ env.SRC_DIR }}"
          [ -f "../scripts/custom-init.sh" ] && chmod +x ../scripts/custom-init.sh && ../scripts/custom-init.sh || echo "⚠️ 未找到自定义脚本"

      - name: 生成编译配置
        run: |
          cd "${{ env.SRC_DIR }}"
          # 获取设备/芯片配置
          if [ "${{ github.event.inputs.select_mode }}" = "device" ]; then
            info=$(jq --arg dev "${{ github.event.inputs.device }}" '.devices[] | select(.name == $dev)' ../device-drivers.json)
          else
            info=$(jq --arg c "${{ github.event.inputs.chip }}" '.chips[] | select(.name == $c)' ../device-drivers.json)
            kernel_target=$(echo "$info" | jq -r '.platform')
            info=$(jq --arg p "$kernel_target" '.devices[] | select(.kernel_target == $p)' ../device-drivers.json | head -n1)
          fi
          
          kernel_target=$(echo "$info" | jq -r '.kernel_target')
          target=$(echo "$kernel_target" | tr '/' '_')
          drivers=$(echo "$info" | jq -r '.drivers[]' | tr '\n' ' ')
          
          # 生成.config
          echo "CONFIG_TARGET_$target=y" >> .config
          echo "CONFIG_TARGET_${target}_DEVICE_generic=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=${{ github.event.inputs.rootfs_size }}" >> .config
          
          # 添加驱动和软件包
          for driver in $drivers; do echo "CONFIG_PACKAGE_$driver=y" >> .config; done
          for pkg in ${{ env.PACKAGES }}; do echo "CONFIG_PACKAGE_$pkg=y" >> .config; done
          
          # 功能配置
          [ "${{ env.ENABLE_IPV6 }}" = "true" ] && echo "CONFIG_IPV6=y" >> .config || echo "# CONFIG_IPV6 is not set" >> .config
          [ "${{ env.ENABLE_ACCEL }}" = "true" ] && echo "CONFIG_PACKAGE_kmod-nf-flow=y" >> .config
          
          # 编译优化
          echo "CONFIG_CFLAGS=${{ env.CFLAGS }}" >> .config
          echo "CONFIG_CXXFLAGS=${{ env.CFLAGS }}" >> .config
          
          # 主题配置
          echo "CONFIG_PACKAGE_luci-theme-${{ env.THEME }}=y" >> .config
          [ "${{ env.THEME }}" != "bootstrap" ] && echo "# CONFIG_PACKAGE_luci-theme-bootstrap is not set" >> .config
          
          make defconfig

      - name: 开始编译
        run: |
          cd "${{ env.SRC_DIR }}"
          echo "使用 ${{ env.THREADS }} 线程编译"
          make -j${{ env.THREADS }} V=s 2>&1 | tee compile.log

      - name: 处理编译成果
        run: |
          base_name="${{ github.event.inputs.device || github.event.inputs.chip }}-${{ github.event.inputs.source_branch }}-${{ env.THEME }}"
          firmware_name="${base_name}-$(date +%Y%m%d)-${{ github.event.inputs.firmware_suffix }}"
          find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" -exec sh -c '
            for file do mv "$file" "${file%.bin}-$1.bin"; done
          ' _ "$firmware_name" \;

      - name: 上传固件
        uses: actions/upload-artifact@v4
        with:
          name: "${{ github.event.inputs.device || github.event.inputs.chip }}-firmware"
          path: ${{ env.SRC_DIR }}/bin/targets/**/*.bin
          retention-days: 30

      - name: 拉取源码（带重试）
        run: |
          # 定义拉取函数（最多重试3次）
          fetch_source() {
            local repo=$1
            local branch=$2
            local retries=3
            local count=0
            while [ $count -lt $retries ]; do
              if git clone --depth 1 --branch "$branch" "$repo" openwrt-src; then
                return 0
              fi
              echo "⚠️ 拉取源码失败，重试第 $((count+1)) 次..."
              count=$((count+1))
              rm -rf openwrt-src  # 清理失败的目录
              sleep 5  # 等待5秒再重试
            done
            echo "❌ 拉取源码失败（已重试3次）"
            exit 1
          }

          # 选择仓库并调用拉取函数
          case "${{ github.event.inputs.source_branch }}" in
            openwrt-23.05)
              fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "openwrt-23.05"
              ;;
            openwrt-master)
              fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "master"
              ;;
            immortalwrt-23.05)
              fetch_source "https://github.com/immortalwrt/immortalwrt.git" "openwrt-23.05"
              ;;
            immortalwrt-master)
              fetch_source "https://github.com/immortalwrt/immortalwrt.git" "master"
              ;;
          esac
          echo "SRC_DIR=$(pwd)/openwrt-src" >> $GITHUB_ENV
      
      - name: 执行自定义初始化脚本
        if: ${{ github.event.inputs.run_custom_script == 'true' }}
        run: |
          cd "${{ env.SRC_DIR }}"
          if [ ! -f "../scripts/custom-init.sh" ]; then
            echo "❌ 错误：自定义脚本 scripts/custom-init.sh 不存在"
            exit 1
          fi
          if ! chmod +x ../scripts/custom-init.sh; then
            echo "❌ 错误：无法为自定义脚本添加执行权限"
            exit 1
          fi
          echo "🔧 开始执行自定义脚本..."
          if ! ../scripts/custom-init.sh; then
            echo "❌ 错误：自定义脚本执行失败（请检查脚本语法）"
            exit 1
          fi
          echo "✅ 自定义脚本执行完成"
     
      - name: 输出固件类型说明
        run: |
          echo "📌 固件类型说明："
          echo "  - 含 'sysupgrade' 的文件：用于设备升级（保留配置）"
          echo "  - 含 'factory' 的文件：用于首次刷写（清空配置）"
          find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" | grep -E "sysupgrade|factory" | while read -r file; do
            echo "  - $file"
          done
      
      - name: 清理编译缓存（首次运行或版本切换时）
        run: |
          if [ -d "openwrt-src" ]; then
            echo "🧹 清理旧编译目录..."
            rm -rf openwrt-src
          fi
        if: ${{ github.event.inputs.source_branch != github.event.repository.default_branch }}  # 版本切换时触发
      
      - name: 固件信息摘要
        run: |
          firmware_path=$(find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" | head -n1)
          if [ -n "$firmware_path" ]; then
            echo "📊 固件信息："
            echo "  - 路径：$firmware_path"
            echo "  - 大小：$(du -h "$firmware_path" | awk '{print $1}')"
            echo "  - 适用设备：${{ github.event.inputs.device || github.event.inputs.chip }}"
            echo "  - 源码版本：${{ github.event.inputs.source_branch }}"
            echo "  - 主题：${{ env.THEME }}"
          fi
          

