name: OpenWrt全功能动态编译系统（完整版）

on:
  workflow_dispatch:
    inputs:
      select_mode:
        type: choice
        description: 编译模式（设备/芯片）
        required: true
        options: [device, chip]

      device:
        type: choice
        description: 设备型号（仅设备模式）
        required: false
        options: [cudy-tr3000, redmi-ac2100, x86-64-generic, phicomm-k2p]  # 自动更新标记

      chip:
        type: choice
        description: 芯片型号（仅芯片模式）
        required: false
        options: [mt7981, mt7621, x86_64, ipq8065, bcm53573]  # 自动更新标记

      source_branch:
        type: choice
        description: 源码分支
        required: true
        options: [openwrt-23.05, openwrt-master, immortalwrt-23.05, immortalwrt-master]

      theme_and_optimization:
        type: choice
        description: 主题+编译优化组合
        required: true
        options:
          - argon-O2-generic
          - argon-O3-armv8
          - argon-O3-x86
          - bootstrap-O2-generic
          - material-Os-generic

      core_features:
        type: choice
        description: 核心功能
        required: true
        options: [ipv6+accel, ipv6-only, accel-only, none]

      packages:
        type: string
        description: 软件包（格式：包1,包2，无需前缀自动补全luci-app-）
        required: false
        default: "openclash,samba,ddns-scripts"

      rootfs_size:
        type: number
        description: 根分区大小(MB，32-2048)
        required: true
        default: 192
        min: 32
        max: 2048

      firmware_suffix:
        type: string
        description: 固件后缀（如版本号或自定义标识）
        required: false
        default: "custom"

      run_custom_script:
        type: boolean
        description: 执行自定义初始化脚本（scripts/custom-init.sh）
        required: true
        default: true

jobs:
  build-firmware:
    name: 编译固件
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
      packages: write

    steps:
      - name: 拉取仓库代码（含子模块）
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: "recursive"  # 支持子模块（如有自定义插件）

      - name: 检查核心配置文件
        run: |
          # 检查设备配置文件
          if [ ! -f "device-drivers.json" ]; then
            echo "❌ 未找到设备配置文件 device-drivers.json，请先运行同步工作流"
            exit 1
          fi
          # 检查自定义脚本（如果启用）
          if [ "${{ github.event.inputs.run_custom_script }}" = "true" ] && [ ! -f "scripts/custom-init.sh" ]; then
            echo "❌ 启用了自定义脚本但未找到 scripts/custom-init.sh"
            exit 1
          fi
          echo "✅ 核心配置文件检查通过"

      - name: 安装完整编译依赖
        run: |
          sudo apt update -y
          sudo apt install -y \
            build-essential libncurses5-dev libncursesw5-dev \
            zlib1g-dev gawk git gettext libssl-dev xsltproc wget unzip \
            python3 python3-pip jq time curl ca-certificates \
            libelf-dev libzstd-dev flex bison  # 补充内核编译依赖
          # 安装Python工具（部分源码依赖）
          pip3 install --upgrade pip
          pip3 install requests
          echo "✅ 编译依赖安装完成"

      - name: 硬件资源详细检测
        run: |
          echo "🖥️ 编译环境信息："
          echo "  - CPU型号：$(grep -m1 'model name' /proc/cpuinfo | cut -d: -f2 | sed -e 's/^ *//')"
          echo "  - 核心数：$(grep -c ^processor /proc/cpuinfo)"
          echo "  - 总内存：$(free -h | awk '/^Mem:/ {print $2}')"
          echo "  - 可用内存：$(free -h | awk '/^Mem:/ {print $7}')"
          echo "  - 磁盘空间：$(df -h / | awk 'NR==2 {print $4}')"
          
          # 写入环境变量（用于线程计算）
          CPU_CORES=$(grep -c ^processor /proc/cpuinfo)
          AVAIL_MEM_MB=$(free -m | awk '/^Mem:/ {print $7}')
          echo "CPU_CORES=$CPU_CORES" >> $GITHUB_ENV
          echo "AVAIL_MEM_MB=$AVAIL_MEM_MB" >> $GITHUB_ENV

      - name: 智能计算编译线程数
        run: |
          # 解析优化级别和架构
          OPT_LEVEL=$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f2)
          ARCH=$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f3)
          
          # 根据优化级别设置基础内存需求（O3比O2更耗内存）
          case "$OPT_LEVEL" in
            O3|Os) MIN_MEM_PER_THREAD=2048 ;;  # 高优化级别内存需求高
            *) MIN_MEM_PER_THREAD=1024 ;;
          esac
          
          # 架构调整（ARMv8架构编译更耗内存）
          if [ "$ARCH" = "armv8" ]; then
            MIN_MEM_PER_THREAD=$((MIN_MEM_PER_THREAD * 3 / 2))  # 增加50%内存需求
          fi
          
          # 计算最大可能线程数（取内存和CPU核心的最小值）
          MAX_THREADS_BY_MEM=$((AVAIL_MEM_MB / MIN_MEM_PER_THREAD))
          MAX_THREADS_BY_CPU=${{ env.CPU_CORES }}
          FINAL_THREADS=$((MAX_THREADS_BY_MEM < MAX_THREADS_BY_CPU ? MAX_THREADS_BY_MEM : MAX_THREADS_BY_CPU))
          
          # 确保线程数至少为1，且高负载场景限制上限
          FINAL_THREADS=$((FINAL_THREADS < 1 ? 1 : FINAL_THREADS))
          if [ "$OPT_LEVEL" = "O3" ] && [ "$FINAL_THREADS" -gt 4 ]; then
            FINAL_THREADS=4  # O3优化限制最大4线程，避免内存溢出
          fi
          
          echo "⚙️ 编译线程配置："
          echo "  - 优化级别：$OPT_LEVEL，架构：$ARCH"
          echo "  - 单线程内存需求：${MIN_MEM_PER_THREAD}MB"
          echo "  - 最终线程数：$FINAL_THREADS"
          echo "THREADS=$FINAL_THREADS" >> $GITHUB_ENV

      - name: 解析编译参数（主题/功能/软件包）
        run: |
          # 解析主题和编译优化
          THEME=$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f1)
          CFLAGS="-$(echo "${{ github.event.inputs.theme_and_optimization }}" | cut -d'-' -f2)"
          echo "THEME=$THEME" >> $GITHUB_ENV
          echo "CFLAGS=$CFLAGS" >> $GITHUB_ENV
          
          # 解析核心功能（IPv6/硬件加速）
          case "${{ github.event.inputs.core_features }}" in
            "ipv6+accel")
              echo "ENABLE_IPV6=true" >> $GITHUB_ENV
              echo "ENABLE_ACCEL=true" >> $GITHUB_ENV
              ;;
            "ipv6-only")
              echo "ENABLE_IPV6=true" >> $GITHUB_ENV
              echo "ENABLE_ACCEL=false" >> $GITHUB_ENV
              ;;
            "accel-only")
              echo "ENABLE_IPV6=false" >> $GITHUB_ENV
              echo "ENABLE_ACCEL=true" >> $GITHUB_ENV
              ;;
            "none")
              echo "ENABLE_IPV6=false" >> $GITHUB_ENV
              echo "ENABLE_ACCEL=false" >> $GITHUB_ENV
              ;;
          esac
          
          # 解析软件包（自动补全luci-app-前缀，跳过已带前缀的包）
          packages="${{ github.event.inputs.packages }}"
          processed_pkgs=$(echo "$packages" | tr ',' '\n' | while read -r pkg; do
            if [[ "$pkg" == "luci-app-"* ]]; then
              echo "$pkg"  # 已带前缀的包直接保留
            else
              echo "luci-app-$pkg"  # 补全前缀
            fi
          done | tr '\n' ' ')
          echo "PACKAGES=$processed_pkgs" >> $GITHUB_ENV
          echo "📦 解析后软件包：$processed_pkgs"

      - name: 拉取OpenWrt源码（增强重试机制）
        run: |
          # 定义带超时和重试的拉取函数
          fetch_source() {
            local repo=$1 branch=$2 timeout=300 retries=5
            echo "📥 拉取源码：$repo（分支：$branch）"
            
            for ((i=1; i<=retries; i++)); do
              if timeout $timeout git clone --depth 1 --branch "$branch" "$repo" openwrt-src; then
                # 检查源码目录是否有效
                if [ -f "openwrt-src/Makefile" ]; then
                  echo "✅ 源码拉取成功（尝试$i次）"
                  return 0
                else
                  echo "⚠️ 源码目录无效，重新拉取..."
                fi
              else
                echo "⚠️ 拉取失败（尝试$i次，剩余$((retries-i))次）"
              fi
              rm -rf openwrt-src
              sleep $((i * 5))  # 重试间隔递增
            done
            
            echo "❌ 源码拉取失败（已尝试$retries次）"
            exit 1
          }
          
          # 根据分支选择仓库
          case "${{ github.event.inputs.source_branch }}" in
            openwrt-23.05)
              fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "openwrt-23.05"
              ;;
            openwrt-master)
              fetch_source "https://git.openwrt.org/openwrt/openwrt.git" "master"
              ;;
            immortalwrt-23.05)
              fetch_source "https://github.com/immortalwrt/immortalwrt.git" "openwrt-23.05"
              ;;
            immortalwrt-master)
              fetch_source "https://github.com/immortalwrt/immortalwrt.git" "master"
              ;;
          esac
          
          # 记录源码目录
          echo "SRC_DIR=$(pwd)/openwrt-src" >> $GITHUB_ENV

      - name: 初始化源码与扩展源（带重试）
        run: |
          cd "${{ env.SRC_DIR }}"
          echo "🔧 初始化源码 feeds..."
          
          # 重试机制更新feeds
          update_feeds() {
            local retries=3
            for ((i=1; i<=retries; i++)); do
              if ./scripts/feeds update -a; then
                return 0
              fi
              echo "⚠️ feeds更新失败（尝试$i次），重试..."
              sleep $((i * 3))
            done
            echo "❌ feeds更新失败"
            exit 1
          }
          
          update_feeds
          ./scripts/feeds install -a
          
          # 添加主题源（根据主题选择）
          if [ "${{ env.THEME }}" = "argon" ]; then
            echo 'src-git argon https://github.com/jerrykuku/luci-theme-argon.git' >> feeds.conf.default
            echo "📌 添加argon主题源"
          elif [ "${{ env.THEME }}" = "material" ]; then
            echo 'src-git material https://github.com/LuttyYang/luci-theme-material.git' >> feeds.conf.default
            echo "📌 添加material主题源"
          fi
          
          # 添加OpenClash源（ImmortalWrt可能已内置，无需重复添加）
          if [[ "${{ env.PACKAGES }}" == *"luci-app-openclash"* && 
                ! "${{ github.event.inputs.source_branch }}" == *"immortalwrt"* ]]; then
            echo 'src-git openclash https://github.com/vernesong/OpenClash.git' >> feeds.conf.default
            echo "📌 添加OpenClash源"
          fi
          
          # 再次更新feeds以应用新增源
          update_feeds
          ./scripts/feeds install -a

      - name: 执行自定义初始化脚本（带日志和超时）
        if: ${{ github.event.inputs.run_custom_script == 'true' }}
        run: |
          cd "${{ env.SRC_DIR }}"
          echo "📝 执行自定义脚本：scripts/custom-init.sh"
          
          # 超时控制（最长30分钟）
          timeout 1800 ../scripts/custom-init.sh > custom-init.log 2>&1
          exit_code=$?
          
          # 检查执行结果
          if [ $exit_code -eq 124 ]; then
            echo "❌ 自定义脚本执行超时（超过30分钟）"
            cat custom-init.log
            exit 1
          elif [ $exit_code -ne 0 ]; then
            echo "❌ 自定义脚本执行失败（退出码：$exit_code）"
            cat custom-init.log
            exit $exit_code
          fi
          
          echo "✅ 自定义脚本执行成功"
          echo "📄 脚本输出日志已保存至custom-init.log"

      - name: 解析设备/芯片配置（增强容错）
        run: |
          # 根据模式提取设备/芯片信息
          if [ "${{ github.event.inputs.select_mode }}" = "device" ]; then
            dev="${{ github.event.inputs.device }}"
            info=$(jq --arg dev "$dev" '.devices[] | select(.name == $dev)' device-drivers.json)
            if [ -z "$info" ]; then
              echo "❌ 设备 $dev 未在device-drivers.json中找到"
              exit 1
            fi
            echo "📌 选中设备：$dev"
          else
            chip="${{ github.event.inputs.chip }}"
            chip_info=$(jq --arg c "$chip" '.chips[] | select(.name == $c)' device-drivers.json)
            if [ -z "$chip_info" ]; then
              echo "❌ 芯片 $chip 未在device-drivers.json中找到"
              exit 1
            fi
            # 从芯片关联的平台获取设备配置
            kernel_target=$(echo "$chip_info" | jq -r '.platforms' | cut -d',' -f1)  # 取第一个平台
            info=$(jq --arg p "$kernel_target" '.devices[] | select(.kernel_target == $p)' device-drivers.json | head -n1)
            echo "📌 选中芯片：$chip（平台：$kernel_target）"
          fi
          
          # 提取内核目标和驱动
          kernel_target=$(echo "$info" | jq -r '.kernel_target')
          drivers=$(echo "$info" | jq -r '.drivers[]' | tr '\n' ' ')
          
          # 验证内核目标有效性
          if [ -z "$kernel_target" ] || [ "$kernel_target" = "null" ]; then
            echo "❌ 无法获取内核目标配置"
            exit 1
          fi
          
          echo "KERNEL_TARGET=$kernel_target" >> $GITHUB_ENV
          echo "DRIVERS=$drivers" >> $GITHUB_ENV
          echo "🔧 内核目标：$kernel_target"
          echo "🔧 关联驱动数：$(echo "$drivers" | wc -w)"

      - name: 生成编译配置文件（.config）
        run: |
          cd "${{ env.SRC_DIR }}"
          target=$(echo "${{ env.KERNEL_TARGET }}" | tr '/' '_')  # 转换路径为目标名（如"mediatek/mt7622" → "mediatek_mt7622"）
          
          echo "📝 生成.config配置文件..."
          > .config  # 清空现有配置
          
          # 核心目标配置
          echo "CONFIG_TARGET_$target=y" >> .config
          echo "CONFIG_TARGET_${target}_DEVICE_generic=y" >> .config  # 通用设备配置
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=${{ github.event.inputs.rootfs_size }}" >> .config  # 根分区大小
          
          # 驱动配置（从device-drivers.json提取）
          for driver in ${{ env.DRIVERS }}; do
            # 过滤无效驱动名（避免空值）
            if [ -n "$driver" ] && [ "$driver" != "null" ]; then
              echo "CONFIG_PACKAGE_$driver=y" >> .config
            fi
          done
          
          # 软件包配置（用户选择的包）
          for pkg in ${{ env.PACKAGES }}; do
            echo "CONFIG_PACKAGE_$pkg=y" >> .config
          done
          
          # 核心功能配置（IPv6/硬件加速）
          if [ "${{ env.ENABLE_IPV6 }}" = "true" ]; then
            echo "CONFIG_IPV6=y" >> .config
            echo "CONFIG_PACKAGE_ipv6helper=y" >> .config  # IPv6辅助工具
            echo "CONFIG_PACKAGE_6in4=y" >> .config       # IPv6隧道
          else
            echo "# CONFIG_IPV6 is not set" >> .config
          fi
          
          if [ "${{ env.ENABLE_ACCEL }}" = "true" ]; then
            echo "CONFIG_PACKAGE_kmod-nf-flow=y" >> .config        # 流量加速
            echo "CONFIG_PACKAGE_kmod-ipt-raw=y" >> .config       # 原始IPTables规则
            echo "CONFIG_PACKAGE_kmod-nft-offload=y" >> .config   # NFT卸载加速
          fi
          
          # 编译优化配置
          echo "CONFIG_CFLAGS=${{ env.CFLAGS }}" >> .config
          echo "CONFIG_CXXFLAGS=${{ env.CFLAGS }}" >> .config
          echo "CONFIG_BUILD_OPTIMIZATION=${{ env.CFLAGS }}" >> .config  # 全局优化级别
          
          # 主题配置（仅保留选中的主题）
          echo "CONFIG_PACKAGE_luci-theme-${{ env.THEME }}=y" >> .config
          # 禁用其他主题
          for theme in argon bootstrap material; do
            if [ "$theme" != "${{ env.THEME }}" ]; then
              echo "# CONFIG_PACKAGE_luci-theme-$theme is not set" >> .config
            fi
          done
          
          # 生成最终配置（自动处理依赖）
          make defconfig
          
          # 预览关键配置（便于调试）
          echo "🔍 关键配置预览："
          grep -E 'TARGET_|ROOTFS_PARTSIZE|IPV6|THEME|CFLAGS' .config

      - name: 开始编译固件（带计时和进度）
        run: |
          cd "${{ env.SRC_DIR }}"
          echo "🚀 开始编译（线程数：${{ env.THREADS }}，优化级别：${{ env.CFLAGS }}）"
          echo "⏱️ 编译开始时间：$(date)"
          
          # 记录编译时间和输出日志
          time make -j${{ env.THREADS }} V=s 2>&1 | tee compile.log
          
          echo "✅ 编译完成"
          echo "⏱️ 编译结束时间：$(date)"

      - name: 编译失败详细分析
        if: failure()
        run: |
          cd "${{ env.SRC_DIR }}"
          echo "❌ 编译失败，错误分析："
          
          # 常见错误类型检测
          if grep -q "out of memory" compile.log; then
            echo "→ 内存不足（建议：减少线程数或降低优化级别）"
          elif grep -q "Killed signal terminated program cc1" compile.log; then
            echo "→ 编译器被系统终止（内存溢出，建议减少线程数）"
          elif grep -q "Package '.*' is missing" compile.log; then
            missing_pkgs=$(grep "Package '.*' is missing" compile.log | awk -F"'" '{print $2}' | sort | uniq | tr '\n' ' ')
            echo "→ 缺失依赖包：$missing_pkgs（建议：检查软件包名称或切换源码分支）"
          elif grep -q "recursive dependency detected" compile.log; then
            echo "→ 软件包依赖冲突（建议：减少勾选的软件包，避免重复功能）"
          elif grep -q "permission denied" compile.log; then
            echo "→ 权限错误（建议：检查自定义脚本是否修改了文件权限）"
          else
            echo "→ 未知错误，最后100行日志："
            tail -n 100 compile.log
          fi
          
          exit 1

      - name: 固件重命名与整理
        run: |
          # 定义固件基础名称（设备/芯片-分支-主题-日期-后缀）
          base_name="${{ github.event.inputs.device || github.event.inputs.chip }}-${{ github.event.inputs.source_branch }}-${{ env.THEME }}"
          firmware_suffix="${{ github.event.inputs.firmware_suffix }}-$(date +%Y%m%d-%H%M)"
          
          # 重命名所有固件文件（添加后缀）
          find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" -exec sh -c '
            for file do
              dir=$(dirname "$file")
              filename=$(basename "$file" .bin)
              new_filename="${filename}-${1}.bin"
              mv "$file" "$dir/$new_filename"
              echo "📦 重命名：$new_filename"
            done
          ' _ "$firmware_suffix" \;
          
          # 生成固件校验和（便于用户验证）
          find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" -exec sh -c '
            for file do
              sha256sum "$file" > "$file.sha256"
              echo "📝 生成校验和：$(basename "$file.sha256")"
            done
          ' _ \;

      - name: 上传编译成果（含日志和配置）
        uses: actions/upload-artifact@v4
        if: always()  # 无论成功失败都上传
        with:
          name: "${{ github.event.inputs.device || github.event.inputs.chip }}-firmware-${{ github.run_id }}"
          path: |
            ${{ env.SRC_DIR }}/bin/targets/**/*.bin
            ${{ env.SRC_DIR }}/bin/targets/**/*.sha256
            ${{ env.SRC_DIR }}/compile.log
            ${{ env.SRC_DIR }}/custom-init.log*
            ${{ env.SRC_DIR }}/.config  # 编译配置文件（便于复现）
          retention-days: 30  # 保留30天
          if-no-files-found: error  # 无文件时标记错误

      - name: 固件类型说明与列表
        run: |
          echo "📌 固件类型说明："
          echo "  - sysupgrade.bin：设备升级文件（保留配置，适用于已安装OpenWrt的设备）"
          echo "  - factory.bin：工厂固件（首次刷写，适用于原厂系统设备）"
          echo "  - *.sha256：固件校验和文件（用于验证完整性）"
          
          echo -e "\n📋 编译成果列表："
          find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" | grep -E "sysupgrade|factory" | while read -r file; do
            echo "  - $(basename "$file")（大小：$(du -h "$file" | awk '{print $1}')）"
          done

      - name: 固件信息摘要
        run: |
          # 查找第一个固件文件作为示例
          firmware_path=$(find "${{ env.SRC_DIR }}/bin/targets/" -name "*.bin" | head -n1)
          if [ -n "$firmware_path" ]; then
            echo -e "\n📊 固件信息摘要："
            echo "  - 路径：$firmware_path"
            echo "  - 大小：$(du -h "$firmware_path" | awk '{print $1}')"
            echo "  - 适用设备/芯片：${{ github.event.inputs.device || github.event.inputs.chip }}"
            echo "  - 源码分支：${{ github.event.inputs.source_branch }}"
            echo "  - 主题：${{ env.THEME }}"
            echo "  - 优化级别：${{ env.CFLAGS }}"
            echo "  - 编译时间：$(date +"%Y-%m-%d %H:%M:%S")"
          fi

      - name: 清理编译缓存（条件触发）
        run: |
          if [ -d "openwrt-src" ]; then
            echo "🧹 清理编译缓存..."
            rm -rf openwrt-src
          fi
        # 仅在源码分支与仓库默认分支不同时清理（避免重复下载）
        if: ${{ github.event.inputs.source_branch != github.event.repository.default_branch }}
